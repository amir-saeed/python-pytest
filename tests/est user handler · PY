"""
Unit Tests for user_handler.py
Uses pytest + moto (no Docker required)
Tests observability implementation compliance
"""

import json
from typing import Any, Dict
from unittest.mock import Mock, patch
from uuid import uuid4

import pytest
from aws_lambda_powertools.utilities.typing import LambdaContext

# Import the handler
from user_handler import handler


# Fixtures
@pytest.fixture
def lambda_context() -> LambdaContext:
    """Mock Lambda context"""
    context = Mock(spec=LambdaContext)
    context.function_name = "user-api-get-user"
    context.request_id = "test-request-id-123"
    context.invoked_function_arn = "arn:aws:lambda:us-east-1:123456789:function:user-api"
    context.memory_limit_in_mb = 128
    context.aws_request_id = "test-request-id-123"
    return context


@pytest.fixture
def api_gateway_event() -> Dict[str, Any]:
    """Mock API Gateway proxy event"""
    return {
        "httpMethod": "GET",
        "path": "/users/user123",
        "pathParameters": {"user_id": "user123"},
        "headers": {
            "Content-Type": "application/json",
            "x-correlation-id": "test-correlation-456",
        },
        "requestContext": {
            "requestId": "apigw-request-789",
            "stage": "dev",
            "identity": {"sourceIp": "192.168.1.1"},
        },
        "body": None,
    }


@pytest.fixture
def api_gateway_event_no_correlation() -> Dict[str, Any]:
    """Event without correlation ID header"""
    return {
        "httpMethod": "GET",
        "path": "/users/user123",
        "pathParameters": {"user_id": "user123"},
        "headers": {"Content-Type": "application/json"},
        "requestContext": {
            "requestId": "apigw-request-999",
            "stage": "dev",
        },
        "body": None,
    }


# Tests
class TestCorrelationID:
    """Section 5.4 - Correlation ID Standards"""

    def test_correlation_id_from_header(
        self, api_gateway_event: Dict, lambda_context: LambdaContext
    ):
        """Test correlation ID is read from X-Correlation-Id header"""
        response = handler(api_gateway_event, lambda_context)
        
        assert response["statusCode"] == 200
        assert response["headers"]["X-Correlation-Id"] == "test-correlation-456"

    def test_correlation_id_fallback_to_request_context(
        self, api_gateway_event_no_correlation: Dict, lambda_context: LambdaContext
    ):
        """Test correlation ID falls back to requestContext.requestId"""
        response = handler(api_gateway_event_no_correlation, lambda_context)
        
        assert response["statusCode"] == 200
        assert response["headers"]["X-Correlation-Id"] == "apigw-request-999"

    def test_correlation_id_generated_if_missing(self, lambda_context: LambdaContext):
        """Test correlation ID is generated if both header and requestContext missing"""
        event = {
            "httpMethod": "GET",
            "path": "/users/user123",
            "pathParameters": {"user_id": "user123"},
            "headers": {},
            "requestContext": {},
            "body": None,
        }
        
        response = handler(event, lambda_context)
        
        assert response["statusCode"] == 200
        correlation_id = response["headers"]["X-Correlation-Id"]
        # Check it's a valid UUID format
        assert len(correlation_id) == 36  # UUID format: 8-4-4-4-12


class TestValidation:
    """Pydantic validation tests"""

    def test_missing_user_id(
        self, api_gateway_event: Dict, lambda_context: LambdaContext
    ):
        """Test validation error when user_id is missing"""
        api_gateway_event["pathParameters"] = {}
        
        response = handler(api_gateway_event, lambda_context)
        
        assert response["statusCode"] == 400
        body = json.loads(response["body"])
        assert body["error"] == "Invalid request"
        assert "details" in body

    def test_empty_user_id(
        self, api_gateway_event: Dict, lambda_context: LambdaContext
    ):
        """Test validation error when user_id is empty"""
        api_gateway_event["pathParameters"] = {"user_id": ""}
        
        response = handler(api_gateway_event, lambda_context)
        
        assert response["statusCode"] == 400


class TestSuccessPath:
    """Happy path tests"""

    def test_successful_user_retrieval(
        self, api_gateway_event: Dict, lambda_context: LambdaContext
    ):
        """Test successful user retrieval returns 200"""
        response = handler(api_gateway_event, lambda_context)
        
        assert response["statusCode"] == 200
        assert response["headers"]["Content-Type"] == "application/json"
        
        body = json.loads(response["body"])
        assert body["user_id"] == "user123"
        assert body["name"] == "John Doe"
        assert body["email"] == "john@example.com"
        assert body["status"] == "active"

    def test_response_structure(
        self, api_gateway_event: Dict, lambda_context: LambdaContext
    ):
        """Test response follows Pydantic schema"""
        response = handler(api_gateway_event, lambda_context)
        body = json.loads(response["body"])
        
        # Required fields from UserResponse
        required_fields = {"user_id", "name", "email", "status"}
        assert required_fields.issubset(body.keys())


class TestErrorHandling:
    """Section 5.2 - Error logging tests"""

    def test_unhandled_exception_returns_500(
        self, api_gateway_event: Dict, lambda_context: LambdaContext
    ):
        """Test unhandled exceptions return 500"""
        with patch("user_handler.get_user_from_database") as mock_db:
            mock_db.side_effect = Exception("Database connection failed")
            
            response = handler(api_gateway_event, lambda_context)
            
            assert response["statusCode"] == 500
            body = json.loads(response["body"])
            assert body["error"] == "Internal server error"
            # Should NOT expose internal error message (Section 5.3 - Sanitization)
            assert "Database connection failed" not in response["body"]


class TestObservability:
    """Test observability features"""

    @patch("user_handler.logger")
    def test_structured_logging(
        self, mock_logger: Mock, api_gateway_event: Dict, lambda_context: LambdaContext
    ):
        """Test structured logs contain required fields (Section 5.1)"""
        handler(api_gateway_event, lambda_context)
        
        # Check that logger.info was called
        assert mock_logger.info.called
        
        # Verify log contains required fields
        call_args = mock_logger.info.call_args_list
        # First call should be "Request received"
        assert any("Request received" in str(call) for call in call_args)

    @patch("user_handler.metrics")
    def test_metrics_emission(
        self, mock_metrics: Mock, api_gateway_event: Dict, lambda_context: LambdaContext
    ):
        """Test custom metrics are emitted (Section 3.1)"""
        handler(api_gateway_event, lambda_context)
        
        # Verify metrics.add_metric was called
        assert mock_metrics.add_metric.called
        
        # Check RequestCount metric was added
        metric_calls = [call[1]["name"] for call in mock_metrics.add_metric.call_args_list]
        assert "RequestCount" in metric_calls
        assert "SuccessCount" in metric_calls

    @patch("user_handler.tracer")
    def test_xray_tracing(
        self, mock_tracer: Mock, api_gateway_event: Dict, lambda_context: LambdaContext
    ):
        """Test X-Ray annotations are added"""
        handler(api_gateway_event, lambda_context)
        
        # Verify tracer methods were called
        assert mock_tracer.put_annotation.called or mock_tracer.put_metadata.called


class TestEnvironmentBehavior:
    """Section 8 - Environment and Stage Behaviour"""

    @patch.dict("os.environ", {"STAGE": "prod", "LOG_LEVEL": "INFO"})
    def test_production_log_level(
        self, api_gateway_event: Dict, lambda_context: LambdaContext
    ):
        """Test production uses INFO level (DEBUG disabled)"""
        response = handler(api_gateway_event, lambda_context)
        assert response["statusCode"] == 200
        # In production, DEBUG logs should not be emitted

    @patch.dict("os.environ", {"STAGE": "dev", "LOG_LEVEL": "DEBUG"})
    def test_non_production_allows_debug(
        self, api_gateway_event: Dict, lambda_context: LambdaContext
    ):
        """Test non-production allows DEBUG logging"""
        response = handler(api_gateway_event, lambda_context)
        assert response["statusCode"] == 200


# Integration-style test
class TestEndToEnd:
    """End-to-end flow test"""

    def test_complete_request_flow(
        self, api_gateway_event: Dict, lambda_context: LambdaContext
    ):
        """Test complete request lifecycle with observability"""
        response = handler(api_gateway_event, lambda_context)
        
        # Verify response structure
        assert response["statusCode"] == 200
        assert "X-Correlation-Id" in response["headers"]
        
        # Verify response body
        body = json.loads(response["body"])
        assert body["user_id"] == "user123"
        assert body["status"] == "active"


# Run with: pytest test_user_handler.py -v
# Run with coverage: pytest test_user_handler.py --cov=user_handler --cov-report=html

'''

âœ… Created Comprehensive Tests!
Test Coverage:

Section 5.4 - Correlation ID Standards âœ…

Read from header
Fallback to requestContext
Generate UUID if missing


Pydantic Validation âœ…

Missing user_id
Empty user_id
Schema validation


Success Path âœ…

200 response
Correct response structure
All required fields


Section 5.2 - Error Handling âœ…

400 for validation errors
500 for server errors
Section 5.3 - No sensitive data leaked


Section 3.1 - Observability âœ…

Structured logging
Metrics emission
X-Ray tracing


Section 8 - Environment Behavior âœ…

Production vs non-production
Log level control


ðŸš€ How to Run:
bash# Basic run
pytest test_user_handler.py -v

# With coverage report
pytest test_user_handler.py --cov=user_handler --cov-report=html

# Specific test class
pytest test_user_handler.py::TestCorrelationID -v

# With output
pytest test_user_handler.py -v -s


'''